# 电竞经理2 - 后端逻辑需求文档

> 本文档基于策划案和前端代码分析，列出所有需要在后端（Tauri/Rust）实现的逻辑模块。

---

## 目录

1. [数据模型与持久化](#1-数据模型与持久化)
2. [核心引擎](#2-核心引擎)
3. [赛季系统](#3-赛季系统)
4. [联赛系统](#4-联赛系统)
5. [国际赛事系统](#5-国际赛事系统)
6. [转会系统](#6-转会系统)
7. [选秀系统](#7-选秀系统)
8. [财务系统](#8-财务系统)
9. [API 接口设计](#9-api-接口设计)
10. [数据迁移与存档](#10-数据迁移与存档)

---

## 1. 数据模型与持久化

### 1.1 选手模型 (Player)

```rust
struct Player {
    id: String,
    name: String,
    english_name: String,
    age: u8,                    // 17-35岁
    position: Position,         // TOP/JUG/MID/ADC/SUP
    nationality: String,

    // 核心属性
    ability: f64,               // 当前实力 (0-100)
    potential: f64,             // 潜力值 (0-100)
    stability: f64,             // 稳定性 (0-1)
    condition: f64,             // 状态值 (0-100)

    // 分类标签
    tag: PlayerTag,             // GENIUS(5%) / NORMAL(75%) / ORDINARY(20%)

    // 合同信息
    team_id: Option<String>,
    contract_years: u8,
    salary: u64,                // 年薪（万元）

    // 统计数据
    career_stats: CareerStats,
    season_stats: SeasonStats,

    // 状态
    is_free_agent: bool,
    is_retired: bool,
    draft_year: Option<u16>,    // 选秀年份
}

enum PlayerTag {
    Genius,     // 天才：潜力90-100，成长快
    Normal,     // 普通：潜力60-89
    Ordinary,   // 平庸：潜力40-59，成长慢
}

enum Position {
    Top, Jungle, Mid, Adc, Support
}
```

### 1.2 战队模型 (Team)

```rust
struct Team {
    id: String,
    name: String,
    short_name: String,         // 简称，如 "T1", "GEN"
    region: Region,

    // 阵容
    roster: Roster,             // 首发5人
    substitutes: Vec<String>,   // 替补（最多2人）

    // 财务
    budget: u64,                // 预算（万元）
    salary_cap: u64,            // 工资帽
    total_salary: u64,          // 当前总工资

    // 成绩
    championship_count: u32,    // 冠军数
    season_records: Vec<SeasonRecord>,

    // 积分
    annual_points: u32,         // 年度积分
    world_ranking: u32,         // 世界排名
}

struct Roster {
    top: String,
    jungle: String,
    mid: String,
    adc: String,
    support: String,
}

enum Region {
    LPL,    // 中国赛区 - 14支战队
    LCK,    // 韩国赛区 - 14支战队
    LEC,    // 欧洲赛区 - 14支战队
    LCS,    // 北美赛区 - 14支战队
}
```

### 1.3 赛季模型 (Season)

```rust
struct Season {
    id: String,                 // "S1", "S2", ...
    number: u32,
    current_phase: GamePhase,
    completed_phases: Vec<GamePhase>,

    // 各赛区数据
    region_data: HashMap<Region, RegionSeasonData>,

    // 国际赛事数据
    msi_data: Option<TournamentData>,
    madrid_data: Option<TournamentData>,
    worlds_data: Option<TournamentData>,
    shanghai_data: Option<TournamentData>,
    claude_data: Option<TournamentData>,
    icp_data: Option<TournamentData>,
    super_data: Option<TournamentData>,

    // 年度积分榜
    annual_rankings: Vec<TeamRanking>,
}

enum GamePhase {
    SpringRegular,      // 春季赛常规赛
    SpringPlayoffs,     // 春季赛季后赛
    MSI,                // MSI季中邀请赛
    Madrid,             // 马德里大师赛
    SummerRegular,      // 夏季赛常规赛
    SummerPlayoffs,     // 夏季赛季后赛
    Claude,             // Claude洲际赛
    Worlds,             // S世界赛
    Shanghai,           // 上海大师赛
    ICP,                // ICP洲际对抗赛
    Super,              // Super洲际邀请赛
    Transfer,           // 转会期
    Draft,              // 选秀
    SeasonEnd,          // 赛季结束
}
```

### 1.4 比赛模型 (Match)

```rust
struct Match {
    id: String,
    tournament_id: String,
    stage: String,              // "regular", "playoffs", "finals"

    team_a: String,
    team_b: String,

    // 比赛结果
    score_a: u8,
    score_b: u8,
    winner: Option<String>,

    // 每局详情
    games: Vec<GameDetail>,

    // 时间
    match_date: DateTime,
    is_completed: bool,
}

struct GameDetail {
    game_number: u8,
    winner: String,
    duration_minutes: u8,

    // MVP
    mvp_player: String,

    // 队伍数据
    team_a_stats: TeamGameStats,
    team_b_stats: TeamGameStats,
}
```

---

## 2. 核心引擎

### 2.1 选手能力引擎 (PlayerEngine)

**功能**：计算选手的实际表现值

```rust
impl PlayerEngine {
    /// 计算选手单场表现
    /// actual_performance = ability + gaussian_noise(0, σ)
    /// σ = base_σ * (1 - stability)
    /// base_σ = 10
    fn calculate_performance(&self, player: &Player) -> f64 {
        let base_sigma = 10.0;
        let sigma = base_sigma * (1.0 - player.stability);

        // Box-Muller变换生成高斯随机数
        let gaussian = self.box_muller_transform();
        let noise = gaussian * sigma;

        (player.ability + noise).clamp(0.0, 100.0)
    }

    /// Box-Muller变换
    fn box_muller_transform(&self) -> f64 {
        let u1: f64 = rand::random();
        let u2: f64 = rand::random();
        (-2.0 * u1.ln()).sqrt() * (2.0 * PI * u2).cos()
    }

    /// 赛季结束时更新选手能力
    fn update_ability_end_of_season(&self, player: &mut Player) {
        let growth = self.calculate_growth(player);
        player.ability = (player.ability + growth).clamp(0.0, 100.0);

        // 年龄增长
        player.age += 1;

        // 检查退役
        if player.age >= 30 && rand::random::<f64>() < self.retirement_probability(player) {
            player.is_retired = true;
        }
    }

    /// 计算成长值
    fn calculate_growth(&self, player: &Player) -> f64 {
        let base_growth = match player.tag {
            PlayerTag::Genius => 3.0,
            PlayerTag::Normal => 1.5,
            PlayerTag::Ordinary => 0.5,
        };

        // 年龄因素：25岁后开始衰退
        let age_factor = if player.age < 25 {
            1.0
        } else {
            1.0 - (player.age - 25) as f64 * 0.1
        };

        // 潜力因素
        let potential_factor = (player.potential - player.ability) / 100.0;

        base_growth * age_factor * potential_factor.max(0.0)
    }
}
```

### 2.2 战力引擎 (PowerEngine)

**功能**：计算战队战力和模拟比赛

```rust
impl PowerEngine {
    /// 计算战队战力
    /// team_power = average(5位首发选手的actual_ability)
    fn calculate_team_power(&self, team: &Team, players: &[Player]) -> f64 {
        let roster_players: Vec<&Player> = team.get_roster_players(players);

        let total_power: f64 = roster_players.iter()
            .map(|p| self.player_engine.calculate_performance(p))
            .sum();

        total_power / 5.0
    }

    /// 模拟单场比赛
    /// 胜率 = sigmoid((power_a - power_b) / σ)
    /// σ = 6 (控制随机性)
    fn simulate_game(&self, team_a: &Team, team_b: &Team, players: &[Player]) -> String {
        let power_a = self.calculate_team_power(team_a, players);
        let power_b = self.calculate_team_power(team_b, players);

        let sigma = 6.0;
        let win_prob_a = 1.0 / (1.0 + (-(power_a - power_b) / sigma).exp());

        if rand::random::<f64>() < win_prob_a {
            team_a.id.clone()
        } else {
            team_b.id.clone()
        }
    }

    /// 模拟BO3比赛
    fn simulate_bo3(&self, team_a: &Team, team_b: &Team, players: &[Player]) -> MatchResult {
        let mut score_a = 0;
        let mut score_b = 0;
        let mut games = Vec::new();

        while score_a < 2 && score_b < 2 {
            let winner = self.simulate_game(team_a, team_b, players);
            if winner == team_a.id {
                score_a += 1;
            } else {
                score_b += 1;
            }
            games.push(winner);
        }

        MatchResult { score_a, score_b, games }
    }

    /// 模拟BO5比赛
    fn simulate_bo5(&self, team_a: &Team, team_b: &Team, players: &[Player]) -> MatchResult {
        let mut score_a = 0;
        let mut score_b = 0;
        let mut games = Vec::new();

        while score_a < 3 && score_b < 3 {
            let winner = self.simulate_game(team_a, team_b, players);
            if winner == team_a.id {
                score_a += 1;
            } else {
                score_b += 1;
            }
            games.push(winner);
        }

        MatchResult { score_a, score_b, games }
    }
}
```

### 2.3 荣誉引擎 (HonorEngine)

**功能**：统一管理所有荣誉记录，包括战队冠军、选手MVP等

#### 荣誉类型定义

```rust
/// 荣誉类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum HonorType {
    // 战队荣誉
    TeamChampion,           // 赛事冠军
    TeamRunnerUp,           // 赛事亚军
    TeamThirdPlace,         // 赛事季军
    TeamRegularSeasonFirst, // 常规赛第一

    // 选手荣誉
    TournamentMVP,          // 赛事MVP（整个赛事表现最佳）
    FinalsMVP,              // 决赛MVP
    RegularSeasonMVP,       // 常规赛MVP
    PlayoffsMVP,            // 季后赛MVP
    MatchMVP,               // 单场MVP（用于累计统计）

    // 选手冠军荣誉（跟随战队）
    PlayerChampion,         // 选手获得冠军（作为冠军队成员）
}

/// 荣誉记录
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HonorRecord {
    pub id: String,
    pub honor_type: HonorType,
    pub season_id: String,           // S1, S2...
    pub tournament_id: String,       // 赛事ID
    pub tournament_name: String,     // 赛事名称（如"S1 MSI季中邀请赛"）
    pub tournament_type: String,     // 赛事类型（spring/msi/worlds等）

    // 获得者（战队或选手）
    pub team_id: Option<String>,
    pub team_name: Option<String>,
    pub player_id: Option<String>,
    pub player_name: Option<String>,
    pub position: Option<String>,    // 选手位置

    // MVP统计数据
    pub stats: Option<HonorStats>,
    pub created_at: DateTime<Utc>,
}

/// MVP统计数据
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HonorStats {
    pub total_impact: f64,           // 总影响力分数
    pub mvp_count: u32,              // 单场MVP次数
    pub games_played: u32,           // 参与局数
    pub wins: u32,                   // 胜场数
    pub avg_performance: f64,        // 平均发挥值
}

/// 选手赛事统计（用于计算MVP）
#[derive(Debug, Clone, Default)]
pub struct PlayerTournamentStats {
    pub player_id: String,
    pub player_name: String,
    pub team_id: String,
    pub team_name: String,
    pub position: String,
    pub total_impact: f64,
    pub games_played: u32,
    pub wins: u32,
    pub mvp_count: u32,              // 单场MVP次数
}
```

#### 荣誉引擎实现

```rust
pub struct HonorEngine {
    db: Database,
}

impl HonorEngine {
    // ========== 记录荣誉 ==========

    /// 记录赛事冠军（战队）
    pub async fn record_team_champion(
        &self,
        season_id: &str,
        tournament_id: &str,
        tournament_name: &str,
        tournament_type: &str,
        team_id: &str,
        team_name: &str,
    ) -> Result<HonorRecord> {
        let record = HonorRecord {
            id: generate_uuid(),
            honor_type: HonorType::TeamChampion,
            season_id: season_id.to_string(),
            tournament_id: tournament_id.to_string(),
            tournament_name: tournament_name.to_string(),
            tournament_type: tournament_type.to_string(),
            team_id: Some(team_id.to_string()),
            team_name: Some(team_name.to_string()),
            player_id: None,
            player_name: None,
            position: None,
            stats: None,
            created_at: Utc::now(),
        };

        self.save_honor(&record).await?;
        Ok(record)
    }

    /// 记录选手冠军荣誉（冠军队所有成员）
    pub async fn record_players_champion(
        &self,
        season_id: &str,
        tournament_id: &str,
        tournament_name: &str,
        tournament_type: &str,
        team_id: &str,
        team_name: &str,
        players: &[Player],  // 冠军队阵容
    ) -> Result<Vec<HonorRecord>> {
        let mut records = Vec::new();

        for player in players {
            let record = HonorRecord {
                id: generate_uuid(),
                honor_type: HonorType::PlayerChampion,
                season_id: season_id.to_string(),
                tournament_id: tournament_id.to_string(),
                tournament_name: tournament_name.to_string(),
                tournament_type: tournament_type.to_string(),
                team_id: Some(team_id.to_string()),
                team_name: Some(team_name.to_string()),
                player_id: Some(player.id.clone()),
                player_name: Some(player.name.clone()),
                position: Some(player.position.to_string()),
                stats: None,
                created_at: Utc::now(),
            };

            self.save_honor(&record).await?;
            records.push(record);
        }

        Ok(records)
    }

    /// 记录赛事MVP
    pub async fn record_tournament_mvp(
        &self,
        season_id: &str,
        tournament_id: &str,
        tournament_name: &str,
        tournament_type: &str,
        player: &PlayerTournamentStats,
    ) -> Result<HonorRecord> {
        let record = HonorRecord {
            id: generate_uuid(),
            honor_type: HonorType::TournamentMVP,
            season_id: season_id.to_string(),
            tournament_id: tournament_id.to_string(),
            tournament_name: tournament_name.to_string(),
            tournament_type: tournament_type.to_string(),
            team_id: Some(player.team_id.clone()),
            team_name: Some(player.team_name.clone()),
            player_id: Some(player.player_id.clone()),
            player_name: Some(player.player_name.clone()),
            position: Some(player.position.clone()),
            stats: Some(HonorStats {
                total_impact: player.total_impact,
                mvp_count: player.mvp_count,
                games_played: player.games_played,
                wins: player.wins,
                avg_performance: player.total_impact / player.games_played as f64,
            }),
            created_at: Utc::now(),
        };

        self.save_honor(&record).await?;
        Ok(record)
    }

    /// 记录决赛MVP
    pub async fn record_finals_mvp(
        &self,
        season_id: &str,
        tournament_id: &str,
        tournament_name: &str,
        tournament_type: &str,
        player_id: &str,
        player_name: &str,
        team_id: &str,
        team_name: &str,
        position: &str,
        stats: HonorStats,
    ) -> Result<HonorRecord> {
        let record = HonorRecord {
            id: generate_uuid(),
            honor_type: HonorType::FinalsMVP,
            season_id: season_id.to_string(),
            tournament_id: tournament_id.to_string(),
            tournament_name: tournament_name.to_string(),
            tournament_type: tournament_type.to_string(),
            team_id: Some(team_id.to_string()),
            team_name: Some(team_name.to_string()),
            player_id: Some(player_id.to_string()),
            player_name: Some(player_name.to_string()),
            position: Some(position.to_string()),
            stats: Some(stats),
            created_at: Utc::now(),
        };

        self.save_honor(&record).await?;
        Ok(record)
    }

    // ========== 赛事结束统一处理 ==========

    /// 赛事结束时统一处理所有荣誉
    pub async fn process_tournament_honors(
        &self,
        season_id: &str,
        tournament: &Tournament,
        final_match: &MatchDetail,
        champion_players: &[Player],
        all_match_details: &[MatchDetail],
    ) -> Result<TournamentHonors> {
        let mut honors = TournamentHonors::default();

        // 1. 记录战队冠军
        honors.team_champion = self.record_team_champion(
            season_id,
            &tournament.id,
            &tournament.name,
            &tournament.tournament_type,
            &final_match.winner_id,
            &final_match.winner_name,
        ).await?;

        // 2. 记录战队亚军
        let runner_up_id = if final_match.winner_id == final_match.team_a_id {
            (&final_match.team_b_id, &final_match.team_b_name)
        } else {
            (&final_match.team_a_id, &final_match.team_a_name)
        };
        honors.team_runner_up = self.record_team_runner_up(
            season_id,
            &tournament.id,
            &tournament.name,
            &tournament.tournament_type,
            runner_up_id.0,
            runner_up_id.1,
        ).await?;

        // 3. 记录冠军队所有选手的冠军荣誉
        honors.player_champions = self.record_players_champion(
            season_id,
            &tournament.id,
            &tournament.name,
            &tournament.tournament_type,
            &final_match.winner_id,
            &final_match.winner_name,
            champion_players,
        ).await?;

        // 4. 计算并记录赛事MVP
        let mvp_candidate = self.calculate_tournament_mvp(all_match_details)?;
        honors.tournament_mvp = self.record_tournament_mvp(
            season_id,
            &tournament.id,
            &tournament.name,
            &tournament.tournament_type,
            &mvp_candidate,
        ).await?;

        // 5. 记录决赛MVP
        if let Some(ref mvp_player_id) = final_match.mvp_player_id {
            let finals_mvp_stats = self.extract_finals_mvp_stats(final_match, mvp_player_id)?;
            honors.finals_mvp = Some(self.record_finals_mvp(
                season_id,
                &tournament.id,
                &tournament.name,
                &tournament.tournament_type,
                mvp_player_id,
                final_match.mvp_player_name.as_ref().unwrap(),
                final_match.mvp_team_id.as_ref().unwrap(),
                "", // team_name
                "", // position
                finals_mvp_stats,
            ).await?);
        }

        Ok(honors)
    }

    /// 计算赛事MVP（累计影响力最高的选手）
    fn calculate_tournament_mvp(
        &self,
        match_details: &[MatchDetail],
    ) -> Result<PlayerTournamentStats> {
        let mut player_stats: HashMap<String, PlayerTournamentStats> = HashMap::new();

        // 遍历所有比赛的所有局
        for match_detail in match_details {
            for game in &match_detail.games {
                // 累计A队选手数据
                for perf in &game.team_a_players {
                    let entry = player_stats.entry(perf.player_id.clone())
                        .or_insert_with(|| PlayerTournamentStats {
                            player_id: perf.player_id.clone(),
                            player_name: perf.player_name.clone(),
                            team_id: game.team_a_id.clone(),
                            team_name: game.team_a_name.clone(),
                            position: perf.position.clone(),
                            ..Default::default()
                        });

                    entry.total_impact += perf.impact_score;
                    entry.games_played += 1;
                    if game.winner_id == game.team_a_id {
                        entry.wins += 1;
                    }
                }

                // 累计B队选手数据
                for perf in &game.team_b_players {
                    let entry = player_stats.entry(perf.player_id.clone())
                        .or_insert_with(|| PlayerTournamentStats {
                            player_id: perf.player_id.clone(),
                            player_name: perf.player_name.clone(),
                            team_id: game.team_b_id.clone(),
                            team_name: game.team_b_name.clone(),
                            position: perf.position.clone(),
                            ..Default::default()
                        });

                    entry.total_impact += perf.impact_score;
                    entry.games_played += 1;
                    if game.winner_id == game.team_b_id {
                        entry.wins += 1;
                    }
                }

                // 记录单场MVP
                if let Some(ref mvp_id) = game.mvp_player_id {
                    if let Some(entry) = player_stats.get_mut(mvp_id) {
                        entry.mvp_count += 1;
                    }
                }
            }
        }

        // 找出累计影响力最高的选手作为赛事MVP
        player_stats.into_values()
            .max_by(|a, b| {
                a.total_impact.partial_cmp(&b.total_impact).unwrap()
            })
            .ok_or(Error::NoMvpFound)
    }

    // ========== 查询方法 ==========

    /// 获取战队所有荣誉
    pub async fn get_team_honors(&self, team_id: &str) -> Result<Vec<HonorRecord>> {
        self.db.query("SELECT * FROM honors WHERE team_id = ? ORDER BY created_at DESC", [team_id]).await
    }

    /// 获取选手所有荣誉
    pub async fn get_player_honors(&self, player_id: &str) -> Result<Vec<HonorRecord>> {
        self.db.query("SELECT * FROM honors WHERE player_id = ? ORDER BY created_at DESC", [player_id]).await
    }

    /// 获取赛季所有荣誉
    pub async fn get_season_honors(&self, season_id: &str) -> Result<Vec<HonorRecord>> {
        self.db.query("SELECT * FROM honors WHERE season_id = ? ORDER BY created_at DESC", [season_id]).await
    }

    /// 获取特定赛事的荣誉
    pub async fn get_tournament_honors(&self, tournament_id: &str) -> Result<Vec<HonorRecord>> {
        self.db.query("SELECT * FROM honors WHERE tournament_id = ? ORDER BY honor_type", [tournament_id]).await
    }

    /// 获取荣誉殿堂数据（按赛事类型分组）
    pub async fn get_honor_hall(&self) -> Result<HonorHallData> {
        let champions = self.db.query(
            "SELECT * FROM honors WHERE honor_type = 'TeamChampion' ORDER BY created_at DESC",
            []
        ).await?;

        let mvps = self.db.query(
            "SELECT * FROM honors WHERE honor_type IN ('TournamentMVP', 'FinalsMVP') ORDER BY created_at DESC",
            []
        ).await?;

        Ok(HonorHallData {
            champions,
            mvps,
        })
    }

    /// 获取选手冠军数量
    pub async fn get_player_champion_count(&self, player_id: &str) -> Result<u32> {
        self.db.query_scalar(
            "SELECT COUNT(*) FROM honors WHERE player_id = ? AND honor_type = 'PlayerChampion'",
            [player_id]
        ).await
    }

    /// 获取战队冠军数量
    pub async fn get_team_champion_count(&self, team_id: &str) -> Result<u32> {
        self.db.query_scalar(
            "SELECT COUNT(*) FROM honors WHERE team_id = ? AND honor_type = 'TeamChampion'",
            [team_id]
        ).await
    }

    /// 获取选手MVP数量
    pub async fn get_player_mvp_count(&self, player_id: &str) -> Result<u32> {
        self.db.query_scalar(
            "SELECT COUNT(*) FROM honors WHERE player_id = ? AND honor_type IN ('TournamentMVP', 'FinalsMVP')",
            [player_id]
        ).await
    }
}

/// 赛事荣誉汇总
#[derive(Debug, Default)]
pub struct TournamentHonors {
    pub team_champion: HonorRecord,
    pub team_runner_up: HonorRecord,
    pub player_champions: Vec<HonorRecord>,
    pub tournament_mvp: HonorRecord,
    pub finals_mvp: Option<HonorRecord>,
}

/// 荣誉殿堂数据
#[derive(Debug, Default, Serialize)]
pub struct HonorHallData {
    pub champions: Vec<HonorRecord>,  // 所有冠军记录
    pub mvps: Vec<HonorRecord>,       // 所有MVP记录
}
```

#### 数据库表设计

```sql
-- 荣誉记录表
CREATE TABLE IF NOT EXISTS honors (
    id TEXT PRIMARY KEY,
    honor_type TEXT NOT NULL,
    season_id TEXT NOT NULL,
    tournament_id TEXT NOT NULL,
    tournament_name TEXT NOT NULL,
    tournament_type TEXT NOT NULL,
    team_id TEXT,
    team_name TEXT,
    player_id TEXT,
    player_name TEXT,
    position TEXT,
    stats_json TEXT,
    created_at TEXT NOT NULL
);

-- 索引优化查询
CREATE INDEX IF NOT EXISTS idx_honors_team ON honors(team_id);
CREATE INDEX IF NOT EXISTS idx_honors_player ON honors(player_id);
CREATE INDEX IF NOT EXISTS idx_honors_season ON honors(season_id);
CREATE INDEX IF NOT EXISTS idx_honors_tournament ON honors(tournament_id);
CREATE INDEX IF NOT EXISTS idx_honors_type ON honors(honor_type);
CREATE INDEX IF NOT EXISTS idx_honors_tournament_type ON honors(tournament_type);
```

#### 调用时机

```rust
// 在赛事管理器中，赛事结束时调用
impl TournamentManager {
    pub async fn complete_tournament(&mut self, tournament_id: &str) -> Result<()> {
        let tournament = self.get_tournament(tournament_id)?;
        let final_match = self.get_final_match(tournament_id)?;
        let champion_players = self.get_team_players(&final_match.winner_id)?;
        let all_matches = self.get_all_match_details(tournament_id)?;

        // 1. 更新积分
        self.points_engine.award_tournament_points(&tournament).await?;

        // 2. 记录荣誉（新增）
        let honors = self.honor_engine.process_tournament_honors(
            &self.current_season_id,
            &tournament,
            &final_match,
            &champion_players,
            &all_matches,
        ).await?;

        // 3. 发送荣誉事件通知前端
        self.emit_event(GameEvent::HonorsAwarded {
            tournament_id: tournament_id.to_string(),
            honors,
        });

        // 4. 更新赛事状态
        self.update_tournament_status(tournament_id, "completed").await?;

        Ok(())
    }
}
```

---

## 3. 赛季系统

### 3.1 赛季流程管理

```rust
impl SeasonManager {
    /// 推进到下一阶段
    fn advance_phase(&mut self) -> Result<(), Error> {
        let current = self.season.current_phase;

        // 执行当前阶段结算
        self.finalize_current_phase()?;

        // 推进到下一阶段
        let next_phase = self.get_next_phase(current);

        if next_phase == GamePhase::SeasonEnd {
            self.end_season()?;
            self.start_new_season()?;
        } else {
            self.season.current_phase = next_phase;
            self.initialize_phase(next_phase)?;
        }

        Ok(())
    }

    /// 阶段顺序
    fn get_next_phase(&self, current: GamePhase) -> GamePhase {
        match current {
            GamePhase::SpringRegular => GamePhase::SpringPlayoffs,
            GamePhase::SpringPlayoffs => GamePhase::MSI,
            GamePhase::MSI => GamePhase::Madrid,
            GamePhase::Madrid => GamePhase::SummerRegular,
            GamePhase::SummerRegular => GamePhase::SummerPlayoffs,
            GamePhase::SummerPlayoffs => GamePhase::Claude,
            GamePhase::Claude => GamePhase::Worlds,
            GamePhase::Worlds => GamePhase::Shanghai,
            GamePhase::Shanghai => GamePhase::ICP,
            GamePhase::ICP => GamePhase::Super,
            GamePhase::Super => GamePhase::Transfer,
            GamePhase::Transfer => GamePhase::Draft,
            GamePhase::Draft => GamePhase::SeasonEnd,
            GamePhase::SeasonEnd => GamePhase::SpringRegular,
        }
    }
}
```

### 3.2 赛季结算

```rust
impl SeasonManager {
    /// 赛季结束处理
    fn end_season(&mut self) -> Result<(), Error> {
        // 1. 更新所有选手能力
        for player in &mut self.players {
            self.player_engine.update_ability_end_of_season(player);
        }

        // 2. 处理退役选手
        self.handle_retirements()?;

        // 3. 合同到期处理
        self.handle_contract_expirations()?;

        // 4. 生成新秀选手（为下一赛季选秀准备）
        self.generate_draft_prospects()?;

        // 5. 归档赛季数据
        self.archive_season_data()?;

        // 6. 重置年度积分
        self.reset_annual_points()?;

        Ok(())
    }
}
```

---

## 4. 联赛系统

### 4.1 常规赛

**赛制**：14支战队双循环 BO3，共26轮182场比赛

```rust
impl RegularSeason {
    /// 生成赛程
    fn generate_schedule(&self, teams: &[Team]) -> Vec<Match> {
        let mut matches = Vec::new();

        // 双循环：每支队伍与其他13支队伍各打2次
        for round in 0..2 {
            for i in 0..teams.len() {
                for j in (i+1)..teams.len() {
                    let (team_a, team_b) = if round == 0 {
                        (&teams[i], &teams[j])
                    } else {
                        (&teams[j], &teams[i])
                    };

                    matches.push(Match::new(team_a.id.clone(), team_b.id.clone()));
                }
            }
        }

        // 打乱顺序分配到26轮
        self.distribute_to_rounds(matches)
    }

    /// 计算积分榜
    fn calculate_standings(&self, matches: &[Match]) -> Vec<Standing> {
        let mut standings: HashMap<String, Standing> = HashMap::new();

        for m in matches.iter().filter(|m| m.is_completed) {
            // 胜者积1分，败者积0分
            standings.entry(m.winner.clone().unwrap())
                .or_default()
                .wins += 1;

            let loser = if m.winner.as_ref() == Some(&m.team_a) {
                &m.team_b
            } else {
                &m.team_a
            };
            standings.entry(loser.clone())
                .or_default()
                .losses += 1;
        }

        // 排序：胜场 > 净胜局 > 相互战绩
        self.sort_standings(standings)
    }
}
```

### 4.2 季后赛

**赛制**：8强双败淘汰 BO5

```rust
impl Playoffs {
    /// 初始化季后赛对阵
    fn initialize_bracket(&mut self, standings: &[Standing]) {
        // 取前8名
        let qualified: Vec<_> = standings.iter().take(8).collect();

        // 胜者组首轮对阵：1v8, 4v5, 2v7, 3v6
        self.winners_bracket = WinnersBracket {
            round1: vec![
                (qualified[0].clone(), qualified[7].clone()),
                (qualified[3].clone(), qualified[4].clone()),
                (qualified[1].clone(), qualified[6].clone()),
                (qualified[2].clone(), qualified[5].clone()),
            ],
            ..Default::default()
        };
    }

    /// 双败淘汰赛流程
    fn advance_match(&mut self, match_id: &str, winner: &str) {
        // 败者进入败者组
        // 最终：败者组冠军 vs 胜者组冠军
    }
}

/// 积分分配
fn get_playoffs_points(placement: u8) -> u32 {
    match placement {
        1 => 90,    // 冠军
        2 => 70,    // 亚军
        3 => 50,    // 季军
        4 => 40,    // 殿军
        5..=6 => 20,
        7..=8 => 10,
        _ => 0,
    }
}
```

---

## 5. 国际赛事系统

### 5.1 MSI 季中邀请赛

**参赛队伍**：各赛区春季赛冠亚季军（共12支）

**赛制**：双败淘汰 BO5

```rust
impl MSITournament {
    /// 获取参赛队伍
    fn get_qualified_teams(&self, spring_playoffs: &HashMap<Region, PlayoffsResult>) -> Vec<Team> {
        let mut teams = Vec::new();

        for region in [Region::LPL, Region::LCK, Region::LEC, Region::LCS] {
            let result = &spring_playoffs[&region];
            teams.push(result.champion.clone());
            teams.push(result.runner_up.clone());
            teams.push(result.third_place.clone());
        }

        teams
    }

    /// 积分分配
    fn get_points(placement: u8) -> u32 {
        match placement {
            1 => 20,    // 冠军
            2 => 16,    // 亚军
            3 => 12,    // 季军
            4 => 8,     // 殿军
            5..=6 => 6, // 败者组R2败者
            7..=8 => 4, // 败者组R1败者
            _ => 0,
        }
    }
}
```

### 5.2 马德里大师赛

**参赛队伍**：各赛区春季赛前8名（共32支）

**赛制**：小组赛 + 淘汰赛

```rust
impl MadridMasters {
    /// 分组
    fn draw_groups(&self, teams: &[Team]) -> Vec<Group> {
        // 8组，每组4队
        // 同赛区不同组
        // 蛇形分组
    }

    /// 积分分配
    fn get_points(placement: u8) -> u32 {
        match placement {
            1 => 30,    // 冠军
            2 => 24,    // 亚军
            3..=4 => 18,
            5..=8 => 12,
            9..=16 => 8,
            17..=32 => 4,
            _ => 0,
        }
    }
}
```

### 5.3 S世界赛

**参赛队伍**：各赛区夏季赛前4名（共16支）

**赛制**：瑞士轮 + 淘汰赛

```rust
impl WorldChampionship {
    /// 瑞士轮赛制
    fn swiss_round(&mut self) -> Vec<Team> {
        // 5轮瑞士轮，3胜晋级，3败淘汰
        // 每轮战绩相同的队伍对阵
    }

    /// 积分分配
    fn get_points(placement: u8) -> u32 {
        match placement {
            1 => 100,   // 冠军
            2 => 80,    // 亚军
            3..=4 => 60,
            5..=8 => 40,
            9..=16 => 20,
            _ => 0,
        }
    }
}
```

### 5.4 上海大师赛

**参赛队伍**：各赛区夏季赛冠亚季军（共12支）

**赛制**：双败淘汰 BO5（同MSI）

### 5.5 Claude洲际赛

**参赛队伍**：各赛区夏季赛冠亚军（共8支）

**赛制**：赛区对抗表演赛

```rust
impl ClaudeRiftRivals {
    /// 积分分配
    fn get_points(placement: u8) -> u32 {
        match placement {
            1 => 15,    // 冠军赛区每队
            2 => 10,
            3 => 6,
            4 => 3,
            _ => 0,
        }
    }
}
```

### 5.6 ICP洲际对抗赛

**参赛队伍**：各赛区前6名（共24支）

**赛制**：赛区对抗积分赛

### 5.7 Super洲际邀请赛

**参赛队伍**：年度积分前16名

**赛制**：淘汰赛 BO5

```rust
impl SuperInvitational {
    /// 获取参赛队伍
    fn get_qualified_teams(&self, annual_rankings: &[TeamRanking]) -> Vec<Team> {
        annual_rankings.iter()
            .take(16)
            .map(|r| r.team.clone())
            .collect()
    }

    /// 积分分配（赛季结束前最后一个积分赛事）
    fn get_points(placement: u8) -> u32 {
        match placement {
            1 => 50,
            2 => 40,
            3..=4 => 30,
            5..=8 => 20,
            9..=16 => 10,
            _ => 0,
        }
    }
}
```

---

## 6. 转会系统

### 6.1 转会市场

```rust
struct TransferMarket {
    listings: Vec<TransferListing>,
    offers: Vec<TransferOffer>,
    completed_transfers: Vec<Transfer>,
}

struct TransferListing {
    player_id: String,
    asking_price: u64,
    listing_team: String,
    interested_teams: Vec<String>,
}

struct TransferOffer {
    player_id: String,
    from_team: String,
    to_team: String,
    offer_amount: u64,
    contract_years: u8,
    contract_salary: u64,
    status: OfferStatus,
}

enum OfferStatus {
    Pending,
    Accepted,
    Rejected,
    Countered,
}
```

### 6.2 AI转会逻辑

```rust
impl AITransferManager {
    /// AI战队评估是否需要补强
    fn evaluate_roster_needs(&self, team: &Team, players: &[Player]) -> Vec<Position> {
        let mut weak_positions = Vec::new();

        for (pos, player_id) in team.roster.iter() {
            let player = players.iter().find(|p| p.id == *player_id).unwrap();

            // 如果位置选手能力低于70或年龄大于28
            if player.ability < 70.0 || player.age > 28 {
                weak_positions.push(pos);
            }
        }

        weak_positions
    }

    /// AI发起转会报价
    fn make_offer(&self, team: &Team, target_player: &Player) -> Option<TransferOffer> {
        // 评估球员价值
        let value = self.evaluate_player_value(target_player);

        // 检查预算
        if team.budget < value {
            return None;
        }

        // 生成报价
        Some(TransferOffer {
            player_id: target_player.id.clone(),
            from_team: target_player.team_id.clone().unwrap(),
            to_team: team.id.clone(),
            offer_amount: value,
            contract_years: self.suggest_contract_years(target_player),
            contract_salary: self.suggest_salary(target_player),
            status: OfferStatus::Pending,
        })
    }

    /// 评估选手价值
    fn evaluate_player_value(&self, player: &Player) -> u64 {
        let base_value = player.ability as u64 * 10; // 万元

        // 年龄调整
        let age_factor = if player.age < 23 {
            1.5
        } else if player.age < 27 {
            1.0
        } else {
            0.6
        };

        // 潜力调整
        let potential_factor = player.potential / 80.0;

        (base_value as f64 * age_factor * potential_factor) as u64
    }
}
```

### 6.3 自由球员签约

```rust
impl FreeAgentMarket {
    /// 获取所有自由球员
    fn get_free_agents(&self) -> Vec<&Player> {
        self.players.iter()
            .filter(|p| p.is_free_agent && !p.is_retired)
            .collect()
    }

    /// 签约自由球员
    fn sign_free_agent(&mut self, team_id: &str, player_id: &str,
                        contract_years: u8, salary: u64) -> Result<(), Error> {
        let player = self.players.iter_mut().find(|p| p.id == player_id)
            .ok_or(Error::PlayerNotFound)?;

        if !player.is_free_agent {
            return Err(Error::PlayerNotFreeAgent);
        }

        player.team_id = Some(team_id.to_string());
        player.contract_years = contract_years;
        player.salary = salary;
        player.is_free_agent = false;

        Ok(())
    }
}
```

---

## 7. 选秀系统

### 7.1 选秀规则

- **选秀周期**：每4个赛季举行一次（S2, S6, S10...）
- **选秀顺序**：上赛季战绩倒序（最差的队伍先选）
- **选秀轮数**：5轮，每轮每队选1人

```rust
impl DraftSystem {
    /// 检查是否是选秀赛季
    fn is_draft_season(&self, season_number: u32) -> bool {
        season_number % 4 == 2 // S2, S6, S10...
    }

    /// 生成选秀新秀
    fn generate_draft_class(&mut self, count: usize) -> Vec<Player> {
        let mut prospects = Vec::new();

        for _ in 0..count {
            let tag = self.random_tag();
            let potential = self.generate_potential(tag);
            let ability = self.generate_initial_ability(potential, tag);

            prospects.push(Player {
                id: generate_uuid(),
                name: self.generate_name(),
                age: 17,
                tag,
                potential,
                ability,
                stability: rand::random::<f64>() * 0.4 + 0.3, // 0.3-0.7
                condition: 80.0,
                is_free_agent: true,
                ..Default::default()
            });
        }

        prospects
    }

    /// 随机生成标签
    fn random_tag(&self) -> PlayerTag {
        let roll: f64 = rand::random();
        if roll < 0.05 {
            PlayerTag::Genius    // 5%
        } else if roll < 0.80 {
            PlayerTag::Normal    // 75%
        } else {
            PlayerTag::Ordinary  // 20%
        }
    }

    /// 根据标签生成潜力
    fn generate_potential(&self, tag: PlayerTag) -> f64 {
        match tag {
            PlayerTag::Genius => rand::random::<f64>() * 10.0 + 90.0,   // 90-100
            PlayerTag::Normal => rand::random::<f64>() * 29.0 + 60.0,   // 60-89
            PlayerTag::Ordinary => rand::random::<f64>() * 19.0 + 40.0, // 40-59
        }
    }

    /// 生成初始能力（基于潜力）
    fn generate_initial_ability(&self, potential: f64, tag: PlayerTag) -> f64 {
        let base = potential * 0.4; // 初始能力为潜力的40%
        let variance = match tag {
            PlayerTag::Genius => 10.0,
            PlayerTag::Normal => 8.0,
            PlayerTag::Ordinary => 5.0,
        };
        (base + rand::random::<f64>() * variance - variance / 2.0).clamp(30.0, 60.0)
    }
}
```

### 7.2 选秀流程

```rust
impl DraftSystem {
    /// 确定选秀顺序
    fn determine_draft_order(&self, teams: &[Team], last_season: &Season) -> Vec<String> {
        // 按上赛季总战绩排序（倒序）
        let mut team_records: Vec<_> = teams.iter()
            .map(|t| {
                let record = last_season.get_team_record(&t.id);
                (t.id.clone(), record.wins, record.losses)
            })
            .collect();

        // 战绩差的先选
        team_records.sort_by(|a, b| {
            let win_rate_a = a.1 as f64 / (a.1 + a.2) as f64;
            let win_rate_b = b.1 as f64 / (b.1 + b.2) as f64;
            win_rate_a.partial_cmp(&win_rate_b).unwrap()
        });

        team_records.into_iter().map(|(id, _, _)| id).collect()
    }

    /// 执行选秀（AI自动选择）
    fn execute_ai_pick(&self, team: &Team, available: &[Player]) -> String {
        // AI优先选择：
        // 1. 补强弱势位置
        // 2. 高潜力选手
        // 3. 年轻选手

        let needs = self.evaluate_roster_needs(team);

        let best_pick = available.iter()
            .filter(|p| needs.contains(&p.position))
            .max_by(|a, b| {
                let score_a = a.potential * 0.7 + a.ability * 0.3;
                let score_b = b.potential * 0.7 + b.ability * 0.3;
                score_a.partial_cmp(&score_b).unwrap()
            });

        best_pick.map(|p| p.id.clone())
            .unwrap_or_else(|| {
                // 如果没有需要的位置，选最好的
                available.iter()
                    .max_by(|a, b| a.potential.partial_cmp(&b.potential).unwrap())
                    .unwrap()
                    .id
                    .clone()
            })
    }
}
```

---

## 8. 财务系统

### 8.1 收入来源

```rust
struct TeamFinances {
    team_id: String,

    // 收入
    prize_money: u64,           // 比赛奖金
    sponsorship: u64,           // 赞助收入
    merchandise: u64,           // 周边销售
    streaming: u64,             // 直播分成

    // 支出
    player_salaries: u64,       // 选手工资
    staff_salaries: u64,        // 员工工资
    facilities: u64,            // 设施维护
    travel: u64,                // 差旅费用

    // 余额
    balance: u64,
}

impl TeamFinances {
    /// 赛季结算
    fn end_season_settlement(&mut self) {
        let total_income = self.prize_money + self.sponsorship +
                          self.merchandise + self.streaming;
        let total_expenses = self.player_salaries + self.staff_salaries +
                            self.facilities + self.travel;

        self.balance = self.balance + total_income - total_expenses;

        // 重置赛季数据
        self.reset_season_data();
    }

    /// 计算赞助收入（基于战队成绩和人气）
    fn calculate_sponsorship(&self, team: &Team, season: &Season) -> u64 {
        let base = 500; // 基础500万

        // 成绩加成
        let performance_bonus = match team.world_ranking {
            1..=4 => 300,
            5..=8 => 200,
            9..=16 => 100,
            _ => 0,
        };

        // 冠军加成
        let championship_bonus = team.championship_count * 50;

        base + performance_bonus + championship_bonus as u64
    }
}
```

### 8.2 奖金分配

```rust
impl PrizeDistribution {
    /// 各赛事奖金池
    fn get_prize_pool(tournament: &str) -> u64 {
        match tournament {
            "worlds" => 2500,        // 2500万美元
            "msi" => 500,
            "madrid" => 300,
            "shanghai" => 300,
            "super" => 400,
            "spring_playoffs" => 200,
            "summer_playoffs" => 200,
            _ => 0,
        }
    }

    /// 奖金分配比例
    fn get_prize_share(placement: u8, tournament: &str) -> f64 {
        match tournament {
            "worlds" => match placement {
                1 => 0.40,
                2 => 0.20,
                3..=4 => 0.10,
                5..=8 => 0.05,
                _ => 0.0,
            },
            _ => match placement {
                1 => 0.50,
                2 => 0.25,
                3..=4 => 0.125,
                _ => 0.0,
            }
        }
    }
}
```

---

## 9. API 接口设计

### 9.1 Tauri Commands

```rust
// 赛季相关
#[tauri::command]
fn get_current_season() -> Result<Season, Error>;

#[tauri::command]
fn advance_phase() -> Result<Season, Error>;

#[tauri::command]
fn get_season_by_id(id: String) -> Result<Season, Error>;

// 战队相关
#[tauri::command]
fn get_all_teams() -> Result<Vec<Team>, Error>;

#[tauri::command]
fn get_team_by_id(id: String) -> Result<Team, Error>;

#[tauri::command]
fn get_teams_by_region(region: String) -> Result<Vec<Team>, Error>;

#[tauri::command]
fn update_team_roster(team_id: String, roster: Roster) -> Result<Team, Error>;

// 选手相关
#[tauri::command]
fn get_all_players() -> Result<Vec<Player>, Error>;

#[tauri::command]
fn get_player_by_id(id: String) -> Result<Player, Error>;

#[tauri::command]
fn get_players_by_team(team_id: String) -> Result<Vec<Player>, Error>;

#[tauri::command]
fn get_free_agents() -> Result<Vec<Player>, Error>;

// 比赛相关
#[tauri::command]
fn simulate_match(team_a: String, team_b: String, format: String) -> Result<MatchResult, Error>;

#[tauri::command]
fn simulate_regular_season(region: String) -> Result<Vec<Match>, Error>;

#[tauri::command]
fn simulate_playoffs(region: String) -> Result<PlayoffsResult, Error>;

#[tauri::command]
fn simulate_tournament(tournament: String) -> Result<TournamentResult, Error>;

// 转会相关
#[tauri::command]
fn get_transfer_listings() -> Result<Vec<TransferListing>, Error>;

#[tauri::command]
fn make_transfer_offer(offer: TransferOffer) -> Result<(), Error>;

#[tauri::command]
fn accept_transfer_offer(offer_id: String) -> Result<Transfer, Error>;

#[tauri::command]
fn sign_free_agent(team_id: String, player_id: String,
                   contract: Contract) -> Result<(), Error>;

// 选秀相关
#[tauri::command]
fn get_draft_prospects() -> Result<Vec<Player>, Error>;

#[tauri::command]
fn execute_draft_pick(team_id: String, player_id: String) -> Result<(), Error>;

#[tauri::command]
fn simulate_draft() -> Result<Vec<DraftPick>, Error>;

// 排行榜相关
#[tauri::command]
fn get_annual_rankings() -> Result<Vec<TeamRanking>, Error>;

#[tauri::command]
fn get_standings(region: String, split: String) -> Result<Vec<Standing>, Error>;

// 荣誉相关
#[tauri::command]
fn get_honor_hall() -> Result<HonorHallData, Error>;

#[tauri::command]
fn get_team_honors(team_id: String) -> Result<Vec<HonorRecord>, Error>;

#[tauri::command]
fn get_player_honors(player_id: String) -> Result<Vec<HonorRecord>, Error>;

#[tauri::command]
fn get_season_honors(season_id: String) -> Result<Vec<HonorRecord>, Error>;

#[tauri::command]
fn get_tournament_honors(tournament_id: String) -> Result<Vec<HonorRecord>, Error>;

#[tauri::command]
fn get_player_champion_count(player_id: String) -> Result<u32, Error>;

#[tauri::command]
fn get_team_champion_count(team_id: String) -> Result<u32, Error>;

#[tauri::command]
fn get_player_mvp_count(player_id: String) -> Result<u32, Error>;

// 存档相关
#[tauri::command]
fn save_game(slot: u8) -> Result<(), Error>;

#[tauri::command]
fn load_game(slot: u8) -> Result<GameState, Error>;

#[tauri::command]
fn get_save_slots() -> Result<Vec<SaveSlot>, Error>;
```

### 9.2 事件系统

```rust
// 前端订阅的事件
enum GameEvent {
    PhaseChanged { old: GamePhase, new: GamePhase },
    MatchCompleted { match_id: String, result: MatchResult },
    TransferCompleted { transfer: Transfer },
    DraftPickMade { team_id: String, player_id: String },
    SeasonEnded { season_id: String },
    PlayerRetired { player_id: String },
    ChampionshipWon { team_id: String, tournament: String },
    // 荣誉事件
    HonorsAwarded { tournament_id: String, honors: TournamentHonors },
}

impl EventEmitter {
    fn emit(&self, event: GameEvent) {
        // 通过Tauri事件系统发送到前端
        self.app_handle.emit_all("game-event", event);
    }
}
```

---

## 10. 数据迁移与存档

### 10.1 存档系统

```rust
struct GameSave {
    version: String,
    created_at: DateTime,
    updated_at: DateTime,

    // 游戏状态
    current_season: Season,
    all_seasons: Vec<Season>,
    teams: Vec<Team>,
    players: Vec<Player>,

    // 玩家数据
    player_team_id: String,      // 玩家控制的战队
    achievements: Vec<Achievement>,
    statistics: GameStatistics,
}

impl SaveManager {
    /// 保存游戏
    fn save_game(&self, slot: u8, state: &GameState) -> Result<(), Error> {
        let save = GameSave {
            version: env!("CARGO_PKG_VERSION").to_string(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            // ... 其他数据
        };

        let path = self.get_save_path(slot);
        let json = serde_json::to_string_pretty(&save)?;
        std::fs::write(path, json)?;

        Ok(())
    }

    /// 加载游戏
    fn load_game(&self, slot: u8) -> Result<GameState, Error> {
        let path = self.get_save_path(slot);
        let json = std::fs::read_to_string(path)?;
        let save: GameSave = serde_json::from_str(&json)?;

        // 版本兼容性检查
        self.migrate_if_needed(&save)?;

        Ok(save.into())
    }

    /// 自动存档
    fn auto_save(&self, state: &GameState) -> Result<(), Error> {
        self.save_game(0, state) // slot 0 为自动存档
    }
}
```

### 10.2 数据迁移

```rust
impl DataMigration {
    /// 版本迁移
    fn migrate_if_needed(&self, save: &GameSave) -> Result<GameSave, Error> {
        let current_version = env!("CARGO_PKG_VERSION");

        if save.version == current_version {
            return Ok(save.clone());
        }

        // 按版本顺序执行迁移
        let mut migrated = save.clone();

        if semver::Version::parse(&save.version)? < semver::Version::parse("0.2.0")? {
            migrated = self.migrate_to_0_2_0(migrated)?;
        }

        if semver::Version::parse(&migrated.version)? < semver::Version::parse("0.3.0")? {
            migrated = self.migrate_to_0_3_0(migrated)?;
        }

        migrated.version = current_version.to_string();
        Ok(migrated)
    }
}
```

---

## 实现优先级

### 第一阶段（核心）

1. ✅ 数据模型定义
2. ✅ PlayerEngine - 选手能力计算
3. ✅ PowerEngine - 战力计算与比赛模拟
4. ✅ 常规赛系统
5. ✅ 季后赛系统
6. ✅ 积分系统
7. HonorEngine - 荣誉记录系统

### 第二阶段（国际赛事）

8. MSI赛事系统
9. 马德里大师赛系统
10. S世界赛系统
11. 上海大师赛系统
12. 其他国际赛事

### 第三阶段（经营系统）

13. 转会系统
14. 选秀系统
15. 财务系统
16. AI战队决策

### 第四阶段（完善）

17. 存档系统
18. 成就系统
19. 数据统计
20. 性能优化

---

## 技术选型建议

| 模块 | 推荐方案 |
|------|----------|
| 数据存储 | SQLite + rusqlite |
| 序列化 | serde + serde_json |
| 随机数 | rand crate |
| 日期时间 | chrono crate |
| 异步运行时 | tokio (如需要) |
| 日志 | tracing crate |
| 错误处理 | thiserror + anyhow |

---

*文档版本: 1.0*
*最后更新: 2025-12-10*
